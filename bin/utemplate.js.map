{"version":3,"file":null,"sources":["../src/helpers.js","../src/alchemist.js","../src/parasite.js","../src/milli.js"],"sourcesContent":["/** @module helpers */\n\n/**\n * Lazy way of turning an item into an Array\n * @function array$\n *\n * @param {Object} it - Array like object\n *\n * @return {Array} - implicit array object\n */\nlet array$ = function (it) {\n  return Array.prototype.slice.call(it, 0)\n}\n\n/**\n * Appends values to an Array,\n * but first replaces undefined values before adding to the end\n *\n * @function combine\n *\n * @param {Array} array - list of existing items\n * @param {Array} values - proposed additions to the lsit\n *\n * @return {Array} - collective array\n */\nfunction combine (array, values) {\n  let index\n\n  array = array.concat([])\n\n  while ((index = array.indexOf(undefined)) !== -1 && values.length > 0) {\n    array[index] = values.shift()\n  }\n\n  return array.concat(values)\n}\n\n/**\n * Returns a modified function with lazy option assocations\n *\n * @function curry\n *\n * @param {Function} method - function to be curried\n *\n * @return {Function} curried functions\n */\nfunction curry$ (method) {\n  /**\n  * Generated method through currying, allowing chainibility\n  * @function transform\n  *\n  * @see combine\n  * @this\n  *\n  * @param {Array} params - arguments array\n  *\n  * @return {Object} piped output from source curry method\n  */\n  function transform (params) {\n    let context\n\n    return function (...input) {\n      let args = combine(params, array$(arguments))\n\n      context = context || this\n\n      if (args.length < method.length || args.some((it) => it === undefined)) {\n        return transform(args)\n      } else {\n        return method.apply(context, args)\n      }\n    }\n  }\n  return method.length <= 1 ? method : transform([])\n}\n\n/**\n * Returns a modified version of a function with negated boolean output\n *\n * @function negated\n *\n * @param {Function} it - method to be negated\n *\n * @return {Function}\n */\nfunction negated$ (it) {\n  return function () {\n    return !it.apply(this, arguments)\n  }\n}\n\n/**\n * Pairs an object into a set of {key, value} arrays\n *\n * @function pair\n *\n * @param {Object} object - collection to be paired\n *\n * @return {Array.<{name: string, value}>}\n */\nfunction pair (object) {\n  return Object.keys(object).map((key) => {\n    return {key: key, value: object[key]}\n  })\n}\n\n/**\n * Curried shortcut to hasOwnProperty\n *\n * @function has\n *\n * @param {Object} object - collection containing property\n * @param {String} property - property name to be checked\n *\n * @return {boolean}\n */\n\nlet has = curry$((object, property) => {\n  return object.hasOwnProperty(property)\n})\n\n/**\n * Recursively brings arrays to the highest level\n *\n * @function flatten\n *\n * @param {Array.<Array>} array - container of the set\n *\n * @return Array\n */\nfunction flatten (array) {\n  let isArray\n  let toArray\n  let fromArray\n\n  isArray = (it) => it.constructor === Array\n  toArray = (it) => isArray(it) ? it : [it]\n  fromArray = (a, b) => a.concat(b)\n\n  while (array.some(isArray)) {\n    array = array.map(toArray).reduce(fromArray)\n  }\n\n  return array\n}\n\n/**\n * Compares reference object to another object\n *\n * @function equals\n *\n * @see has\n * @see pair\n *\n * @param {Object} reference - what should be compared to\n * @param {Object} object - what we are comparing\n *\n * @return {boolean}\n */\nfunction equals (reference, object) {\n  // Are they of the same type?\n  if (typeof reference !== typeof object ||\n      reference.constructor !== object.constructor) {\n    return false\n  }\n\n  // Do we need to check recursively?\n  if (reference.constructor !== Object) {\n    return reference === object\n  }\n\n  return flatten([\n    pair(reference),\n    pair(object)\n  ])\n  .every((item) => {\n    return has(reference)(item.key) && has(object)(item.key) && equals(reference[item.key], object[item.key])\n  })\n}\n/**\n * Checks to see if an item exists (isn't null or undefined)\n * @function exists\n *\n * @param {Object} it - the item in question of existance\n *\n * @return {boolean}\n */\nfunction exists (it) {\n  return it !== undefined && it !== null\n}\n\n/**\n * Attempts to apply mutation to subject, but returns the unmodified subject on failure\n *\n * @function attempt\n *\n * @see array$\n *\n * @param {Function} mutation - mutator function to be called on the subject\n * @param {Object} subject - any input that should be mutated\n *\n * @return {Object}\n */\nfunction attempt (mutation, subject) {\n  let parameters\n  let alternative\n  let response\n\n  parameters = array$(arguments).slice(1)\n  alternative = parameters.length === 1 ? parameters[0] : parameters\n\n  response = mutation.apply(this, parameters)\n\n  return response || alternative\n}\n\n/**\n * Clones an object\n *\n * @function clone\n *\n * @param {Object} object - object to be cloned\n *\n * @return {Object}\n */\nfunction clone (object) {\n  return Object.assign({}, object)\n}\n\n/**\n * Injects a transformer into each element of a collection\n *\n * @name inject(it, transformer)\n *\n * @see attempt\n *\n * @param {Object} it - collection\n * @param {Function} tranform - mutator function\n *\n * @return {Object.<string, Function>}\n */\nfunction inject (it, transform) {\n  let copy = {}\n\n  function cycle (key, value) {\n    if (value === copy) {\n      return false\n    }\n\n    if (typeof value === 'function') {\n      return attempt(transform, value)\n    }\n\n    if (typeof value === 'object') {\n      return inject(value, transform)\n    }\n\n    // return value;\n  }\n\n  for (let key in it) {\n    copy[key] = cycle(key, it[key])\n  }\n\n  return copy\n};\n\n/**\n * Prepares function collection by currying and adding a not chain\n *\n * @name prepare(it)\n *\n * @see inject\n * @see negated$\n * @see curry$\n *\n * @param {Object.<string, Function>} it - collection of functions\n *\n * @return {Object.<string, Function>} - curried functions object\n */\nfunction prepare (it) {\n  let not, tmp\n\n  not = inject(it, negated$)\n  not = inject(not, curry$)\n  tmp = inject(it, curry$)\n\n  tmp.not = not\n\n  return tmp\n}\n\n/**\n * Applies functions to a value and moves down the chain if possible\n *\n * @function decompose\n *\n * @see exists\n * @see attempt\n * @see array$\n *\n * @param {Array} array - list of functions to be applied\n * @param {Object} initial - optional initial item\n *\n * @return Object\n */\nfunction decompose (array, initial) {\n  let composer = (previous, current) => attempt(current, previous)\n  let reducer = (it) => array.reduce(composer, initial || it)\n\n  return initial ? reducer(initial) : reducer\n}\n\nlet is$ = {\n  element: (object) => {\n    // return object instanceof Element;\n    return object.nodeType === document.ELEMENT_NODE\n  },\n\n  fragment: (object) => {\n    // return object.constructor === DocumentFragment;\n    return object.nodeType === document.DOCUMENT_FRAGMENT_NODE\n  },\n\n  text: (object) => {\n    // return child.constructor === Text;\n    return object.nodeType === document.TEXT_NODE\n  },\n\n  equal: equals,\n  existant: exists\n}\n\nis$ = prepare(is$)\n\nclass Compare {\n  constructor (reference) {\n    this.reference = reference\n  }\n\n  element (object) {\n    let result\n\n    let isElementNode = (it) =>\n      it.nodeType === document.ELEMENT_NODE\n\n    // let isElement = it =>\n    //   object instanceof Element;\n\n    result = isElementNode(object)\n\n    return result === !this.reference.polarity\n  }\n\n  fragment (object) {\n    let result\n\n    let isDocumentFragmentNode = (it) =>\n      it.nodeType === document.DOCUMENT_FRAGMENT_NODE\n\n    // let isDocumentFragment = it =>\n    //   it.constructor === DocumentFragment;\n\n    result = isDocumentFragmentNode(object)\n\n    return result === !this.reference.polarity\n  }\n\n  text (object) {\n    let isTextNode = (it) =>\n      object.nodeType === document.TEXT_NODE\n\n    // let isText = it =>\n    //   child.constructor === Text;\n\n    result = isTextNode(object)\n\n    return result === !this.reference.polarity\n  }\n\n  equals (object, $reference) {\n    let reference = $reference || $reference\n  }\n\n  existant (object) {\n\n  }\n\n}\n\nexport let is = is$\nexport let as = {\n  array: array$,\n  pair: pair,\n  method: curry$,\n  flatten: flatten,\n  decomposed: decompose,\n  attempt: attempt\n}\n//\n// console.log(is$.not.equal({a: 'b'}, {a: 'b', c: 'd'}));\n","import {is, as} from './helpers'\n\n// transmutating elements =)\nexport default class Alchemist {\n  constructor (element) {\n    this.setElement(element)\n  }\n\n  static fromQuerySelector (element) {\n    // find specified element\n    if (typeof element === 'string') {\n      return document.querySelector(element)\n    }\n  }\n\n  static fromSizzle (element) {\n    // it's a jQuery node\n    // if (typeof jQuery !== 'undefined' && element.constructor === jQuery) {\n    if (typeof element.get === 'function') {\n      return element.get(0)\n    }\n    // }\n  }\n\n  static fromTemplate (element) {\n    // html5 template content\n\n    if (is.element(element)) {\n      return element.content\n    }\n  }\n\n  static fromFragment (element) {\n    // defragment\n    if (is.fragment(element) && element.hasChildNodes()) {\n      return element.firstElementChild\n    }\n  }\n\n  static asElement (element) {\n    let waterfall = [\n      Alchemist.fromQuerySelector,\n      Alchemist.fromSizzle,\n        // Alchemist.fromTemplate,\n      Alchemist.fromFragment\n    ]\n\n    let result = as.decomposed(waterfall, element)\n\n    // element is already provided\n    if (result && is.element(result)) {\n      return result\n    }\n  }\n\n  setElement (element) {\n    this.element = Alchemist.asElement(element)\n    return this\n  }\n\n  getElement () {\n    return this.element\n  }\n}\n","// leeches off of the information...\r\nimport {is, as} from './helpers'\r\n\r\nexport default class Parasite {\r\n  constructor (mutator) {\r\n    this.setMutator(mutator)\r\n  }\r\n\r\n  getChildren (element) {\r\n    // Extternal helpers::as.array\r\n\r\n    if (typeof element.content !== 'undefined') {\r\n      element = element.content\r\n    }\r\n\r\n    return as.array(element.childNodes)\r\n  }\r\n\r\n  allChildren (element) {\r\n    // External helpers::is.element helpers::as.flatten\r\n    // Dependencies: getChildren\r\n\r\n    let map = function (child) {\r\n      return (!is.element(child)) ? child : this.allChildren(child)\r\n    }.bind(this)\r\n\r\n    let children = this.getChildren(element).map(map)\r\n\r\n    return as.flatten(children)\r\n  }\r\n\r\n  getAttributes (element) {\r\n    // External helpers::as.array\r\n\r\n    return as.array(element.attributes)\r\n  }\r\n\r\n  setChildren (element) {\r\n    // External: helpers::is.element helpers::is.existant\r\n\r\n    let attributes = this.setAttributes(element)\r\n    let children = this.getChildren(element)\r\n\r\n    for (let key in children) {\r\n      let child = children[key]\r\n      let result\r\n\r\n      if (is.text(child)) {\r\n        if (child.textContent.trim().length > 0) {\r\n          result = this.mutator.apply(child, [\r\n            child.textContent,\r\n            arguments[1],\r\n            children\r\n          ])\r\n        }\r\n      }\r\n\r\n      if (is.element(child)) {\r\n        this.setChildren(child)\r\n      }\r\n\r\n      if (is.existant(result)) {\r\n        child.textContent = result\r\n      }\r\n    };\r\n\r\n    return element\r\n  }\r\n\r\n  setAttributes (element) {\r\n    // External: helpers::is.existant\r\n    // Dependencies: getAttributes\r\n\r\n    let attributes = this.getAttributes(element)\r\n\r\n    for (let index in attributes) {\r\n      let attribute = attributes[index]\r\n      let result\r\n      let name\r\n      let value\r\n\r\n      name = attribute.name\r\n      value = attribute.value\r\n\r\n      if (element.hasAttribute(name) && value.trim().length > 0) {\r\n        result = this.mutator.apply(element, [\r\n          attribute.value,\r\n          attribute.name,\r\n          attributes\r\n        ])\r\n      }\r\n\r\n      if (is.existant(result)) {\r\n        element.setAttribute(attribute.name, result)\r\n      }\r\n    }\r\n\r\n    return attributes\r\n  }\r\n\r\n  infect (element) {\r\n    // Dependencies: setChildren\r\n\r\n    element = this.setChildren(element)\r\n\r\n    this.infection = element\r\n\r\n    return element\r\n  }\r\n\r\n  addChildren (element) {\r\n    // External: helpers::is.not.equal\r\n    // Dependencies: getChildren\r\n\r\n    let infection\r\n    let children\r\n    let sibilings\r\n\r\n    children = this.getChildren(this.infection)\r\n    sibilings = this.getChildren(element)\r\n\r\n    for (let index in children) {\r\n      let child = children[index]\r\n      sibilings.every((it) => is.not.equal(child, it)) && element.appendChild(child)\r\n    }\r\n\r\n    return children\r\n  }\r\n\r\n  setMutator (mutator) {\r\n    this.mutator = mutator\r\n  }\r\n}\r\n","import {version} from '../package.json'\r\nimport Alchemist from './alchemist'\r\nimport Parasite from './parasite'\r\nimport {is, as} from './helpers'\r\n\r\nlet query = (object, property) => {\r\n  let regexp = /[.{}]/g\r\n  let filter = (source) => source\r\n  let reduce = (source, key) => source[key]\r\n\r\n  return property\r\n  .split(regexp)\r\n  .filter(filter)\r\n  .reduce(reduce, object)\r\n}\r\n\r\nlet compile = (value, data) => {\r\n  let regexp = /\\{([^}]+)\\}/g\r\n\r\n  let replacement = (original, property) => {\r\n    return query(data, property) || ''\r\n  }\r\n\r\n  return value\r\n  .trim()\r\n  .replace(regexp, replacement)\r\n}\r\n\r\nlet genetics = function (source) {\r\n  return (input) => compile(input, source)\r\n}\r\n\r\nexport default class Milli {\r\n\r\n  constructor (source) {\r\n    this.source = Alchemist.asElement(source)\r\n    this.methods = []\r\n    this.sources = []\r\n  }\r\n\r\n  static get version () {\r\n    return version\r\n  }\r\n\r\n  setMutations (source) {\r\n    let methods\r\n\r\n    methods = this.methods\r\n  }\r\n\r\n  setSources (method) {\r\n    let sources\r\n\r\n    sources = this.sources.map(method)\r\n\r\n    this.sources = sources\r\n  }\r\n\r\n  provide () {\r\n    let output\r\n\r\n    output = this.output\r\n\r\n    if (is.not.existant(output)) {\r\n      return false\r\n    }\r\n\r\n    this.setSources((source) => {\r\n      if (is.existant(source.children)) {\r\n        return source\r\n      }\r\n\r\n      let parasite\r\n      let compiled\r\n      let children\r\n\r\n      parasite = source.parasite\r\n      compiled = source.compiled\r\n\r\n      children = parasite.addChildren(output)\r\n      source.children = children\r\n\r\n      return source\r\n    })\r\n  }\r\n\r\n  generate () {\r\n    let template\r\n    let methods\r\n\r\n    template = this.source\r\n    methods = this.methods\r\n\r\n    let isInfected = (it) => {\r\n      let content = it.parsed || it.content\r\n\r\n      if (is.not.existant(it.parasite)) {\r\n        it.parasite = new Parasite(genetics(content))\r\n      }\r\n\r\n      return it.parasite\r\n    }\r\n\r\n    let isCompiled = (it) => {\r\n      if (is.not.existant(it.compiled)) {\r\n        let cloned = template.cloneNode(true)\r\n        let element = it.parasite.infect(cloned)\r\n      }\r\n\r\n      return it.compiled\r\n    }\r\n\r\n    let eachMutation = (it) => {\r\n      let result\r\n\r\n      result = methods.reduce(function (previous, current, index) {\r\n        let rendered\r\n\r\n        rendered = current(previous)\r\n        it.mutations[index] = rendered\r\n\r\n        return rendered || previous\r\n      }, it.content)\r\n\r\n      it.parsed = result\r\n\r\n      return result\r\n    }\r\n\r\n    let isMutation = (it) => {\r\n      if (is.not.existant(it.mutations)) {\r\n        it.mutations = []\r\n      }\r\n\r\n      if (it.mutations.length < methods.length) {\r\n        eachMutation(it)\r\n      }\r\n\r\n      return it.mutations\r\n    }\r\n\r\n    this.setSources((source) => {\r\n      let mutation = isMutation(source)\r\n      let infected = isInfected(source)\r\n      let compiled = isCompiled(source)\r\n\r\n      return source\r\n    })\r\n  }\r\n\r\n  setDestination (it) {\r\n    let element\r\n\r\n    element = Alchemist.asElement(it)\r\n\r\n    if (is.not.existant(element)) {\r\n      return false\r\n    }\r\n\r\n    this.output = element\r\n\r\n    if (this.sources.length > 0) {\r\n      this.provide()\r\n    }\r\n\r\n    return element\r\n  }\r\n\r\n  fromObject (it) {\r\n    let packet\r\n\r\n    if (it.constructor !== Object) {\r\n      return false\r\n    }\r\n\r\n    packet = {}\r\n    packet.content = it\r\n\r\n    this.sources.push(packet)\r\n\r\n    this.generate()\r\n    this.provide()\r\n\r\n    return it\r\n  }\r\n\r\n  fromMethod (it) {\r\n    if (it.constructor !== Function) {\r\n      return false\r\n    }\r\n\r\n    this.generate()\r\n    this.methods.push(it)\r\n\r\n    return it\r\n  }\r\n\r\n  pipe (object) {\r\n    let waterfall\r\n    let result\r\n\r\n    waterfall = [\r\n      this.setDestination,\r\n      this.fromObject,\r\n      this.fromMethod\r\n    ]\r\n\r\n    waterfall.some(method => result = method.call(this, object))\r\n\r\n    return this\r\n  }\r\n}\r\n"],"names":["array$","it","Array","prototype","slice","call","combine","array","values","index","concat","indexOf","undefined","length","shift","curry$","method","transform","params","context","input","args","arguments","some","apply","negated$","pair","object","Object","keys","map","key","value","has","property","hasOwnProperty","flatten","isArray","toArray","fromArray","constructor","a","b","reduce","equals","reference","every","item","exists","attempt","mutation","subject","parameters","alternative","response","inject","copy","cycle","prepare","not","tmp","decompose","initial","composer","previous","current","reducer","is$","nodeType","document","ELEMENT_NODE","DOCUMENT_FRAGMENT_NODE","TEXT_NODE","Compare","result","isElementNode","polarity","isDocumentFragmentNode","isTextNode","$reference","is","as","Alchemist","element","setElement","asElement","querySelector","get","content","fragment","hasChildNodes","firstElementChild","waterfall","fromQuerySelector","fromSizzle","fromFragment","decomposed","Parasite","mutator","setMutator","childNodes","child","allChildren","bind","children","getChildren","attributes","setAttributes","text","textContent","trim","setChildren","existant","getAttributes","attribute","name","hasAttribute","setAttribute","infection","sibilings","equal","appendChild","query","regexp","filter","source","split","compile","data","replacement","original","replace","genetics","Milli","methods","sources","output","setSources","parasite","compiled","addChildren","template","isInfected","parsed","isCompiled","cloned","cloneNode","infect","eachMutation","rendered","mutations","isMutation","infected","provide","packet","push","generate","Function","setDestination","fromObject","fromMethod","version"],"mappings":"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"}